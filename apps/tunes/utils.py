import random

from django.conf import settings
from django.core.cache import cache

from accounts.models import UserSongVote
from tunes.models import Song


def generate_browse_playlist(
        energy,
        valence,
        danceability,
        strategy=None,
        limit=None,
        jitter=None,
        artist=None,
        top_artists=None,
        songs=None
):
    """
    Build a browse playlist of songs for the given criteria.

    Given the attributes to search for, will return a list of songs based on the criteria.

    To have more control over the variability of songs returned, specify a `strategy`
    to use in looking up songs. This will force the query to only  use the `strategy`
    attribute specified when filtering songs.
        Example: specifying `energy` as the strategy will only filter
        songs by the given energy, plus and minus the jitter.

    :param energy: (float) Energy estimate of `Song` records returned
    :param valence: (float) Valence estimate of `Song` records returned
    :param danceability: (float) Danceability estimate of `Song` records returned
    :param strategy: (str) Attribute to use in filtering playlist
    :param limit: (int) Optional max numbers of songs to return (can return fewer than the limit!)
    :param artist: (str) Optional artist of songs to return
    :param jitter: (float) Optional "shuffle" for the boundary box to give users songs from outside their norm
    :param top_artists: (list[str]) Optional array of top artists for user in Spotify to use in search
    :param songs: (QuerySet) Optional queryset of songs to filter

    :return playlist: (QuerySet) `QuerySet` of `Song` instances for the given parameters
    """
    energy_lower_limit = energy_upper_limit = energy
    valence_lower_limit = valence_upper_limit = valence
    danceability_lower_limit = danceability_upper_limit = danceability

    if songs is None:
        songs = Song.objects.all()

    if jitter:
        energy_lower_limit -= jitter
        energy_upper_limit += jitter

        valence_lower_limit -= jitter
        valence_upper_limit += jitter

        danceability_lower_limit -= jitter
        danceability_upper_limit += jitter

    params = {
        'energy__range': (energy_lower_limit, energy_upper_limit),
        'valence__range': (valence_lower_limit, valence_upper_limit),
        'danceability__range': (danceability_lower_limit, danceability_upper_limit),
    }

    # Use a singular attribute for generating browse playlist if specified
    # Instead of using all attributes for filtering songs, only use one of
    # the datapoints we have for song emotion affect
    if strategy:
        if strategy not in settings.BROWSE_PLAYLIST_STRATEGIES:
            raise ValueError(
                'Invalid strategy, must be one of: {}'.format(', '.join(settings.BROWSE_PLAYLIST_STRATEGIES))
            )

        params = {key: params[key] for key in params if key.startswith(strategy)}

    playlist = songs.filter(**params).order_by('?')

    # Filter by artist if provided, skipping over top_artists filter
    # to ensure we return tracks from specified artist when provided
    if artist:
        playlist = playlist.filter(artist__icontains=artist)

    # Filter by user top artists on Spotify if provided
    elif top_artists:
        top_artists_playlist = playlist.filter(artist__in=top_artists)

        if top_artists_playlist:

            if limit and top_artists_playlist.count() < limit:
                # If playlist filtered by top artists contains fewer songs than the limit,
                # fill it out with songs from other artists. This ensures we don't return
                # a small playlist if the top artist playlist is less than the desired limit
                playlist_minus_top_artists = playlist.exclude(artist__in=top_artists)
                filler_track_count = limit - top_artists_playlist.count()
                top_artists_playlist = top_artists_playlist.union(playlist_minus_top_artists[:filler_track_count])

            playlist = top_artists_playlist

    playlist = list(playlist)
    random.shuffle(playlist)

    if limit:
        playlist = playlist[:limit]

    return playlist


class CachedPlaylistManager(object):
    """Facilitates caching and retrieving the last previous user browse playlists"""

    def __init__(self, user):
        self.user = user

    def _make_cache_key(self):
        """
        Make a cache key for storing the last previously seen playlist for the user.

        :return: (str)
        """
        return 'browse:cached-playlist:{}'.format(self.user.username)

    def cache_browse_playlist(self, playlist, emotion, context, description):
        """
        Cache the playlist generated by the user for use in retrieving the last seen playlist

        :param playlist: (QuerySet) Playlist recently generated by the user
        :param emotion: (str) Emotion user requested for the browse playlist
        :param context: (str) Optional context set when generating the browse playlist
        :param description: (str) Optional description set when generating the browse playlist
        """
        cache_key = self._make_cache_key()

        cache_data = {
            'emotion': emotion,
            'context': context,
            'description': description,
            'playlist': playlist
        }

        cache.set(cache_key, cache_data, settings.BROWSE_PLAYLIST_CACHE_TIMEOUT)

    def retrieve_cached_browse_playlist(self):
        """
        Retrieve the cached playlist for user if one exists, else return None.

        :return: (list|None)
        """
        cache_key = self._make_cache_key()
        return cache.get(cache_key)


def filter_duplicate_votes_on_song_from_playlist(user_votes):
    """
    Filter queryset of UserSongVotes on unique songs (prevent the same song from appearing twice in the playlist
    even if there are multiple votes for the song)

    :param user_votes: (QuerySet) Collection of votes a user has previously voted as making them feel an Emotion

    :return: (Queryset) Collection of votes without duplicate votes for the same song
    """
    vote_ids = user_votes.distinct('song__code').values_list('id', flat=True)

    return UserSongVote.objects.select_related('song').filter(id__in=vote_ids).order_by('-created')
